<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
  </head>
  <body>
    <script>
      // arr
      const arr = [10, 20, 30];
      arr[0] = 100; // const는 값의 변화가 안된다고 하지 않았나? // 변경가능, mutable
      // arr = 100; // error(var, let일 때는 가능)
      // arr = [10, 20, 30]; // error
      console.log(arr);
      console.dir(arr); // 프러퍼티와 메소드를 볼 수 있다.

      // 문자열(string)
      const s = "hello world";
      console.log(s[0]); // h
      s[0] = "i"; // 불변, immutable
      console.log(s[0]); // h

      // 숫자로 들어간 값은 대괄호로 호출할 수 있고
      // length는 문자. 문자로 입력된 값은 .을찍어서 호출할 수도, 대괄호로 호출할 수도 있습니다.
      // console.log(arr.1) // error
      console.log(arr[1]);
      console.log(arr.length);
      console.log(arr["length"]);

      // 두개가 같은 얘기입니다.
      arr.length = 10;
      arr[0] = 100;

      console.log(arr); // [100, 20, 30, empty x 7]

      // 프로퍼티를 추가하는 것도 가능합니다.
      arr["leehojun"] = 100;
      arr.hojun = 1000;

      console.log(arr); // [100, 20, 30, empty x 7, leehojun: 100, hojun: 1000]

      // 배열의 특징
      let arr2 = new Array(4, 5, 6);
      console.log(arr2); // [4, 5, 6]
      arr2 = new Array(3);
      console.log(arr2); // [empty x 3] (길이가 3인 배열 생성)
      console.log(Array(100).fill(0)); // 길이가 100이고 0으로 채워진 배열

      // 1. 배열은 순서가 있습니다. 배열의 순서를 index, 이 순서로 호출하는 것을 indexing이라고 합니다. 배열 안에 값을 원소(elements)라고 합니다.
      // const arr = [10, 20, 30];
      // arr[0] = 100;

      // 2. 배열에 다른 원시타입과 객체타입을 포함할 수 있습니다.
      //   const arr = [
      //     [1, 2, 3],
      //     [4, 5, 6],
      //     [7, 8, 9],
      //   ];

      //   arr[0];
      //   // [1, 2, 3]
      //   arr[1];
      //   // [4, 5, 6]
      //   arr[2];
      //   // [7, 8, 9]
      //   arr[1][2];
      //   // 6

      //   // 0차원, 1차원, 2차원, 3차원, 다차원
      //   const a = 10; // 스칼라
      //   const b = [10, 20, 30]; // 벡터
      //   const c = [
      //     [1, 2, 3],
      //     [4, 5, 6],
      //     [7, 8, 9],
      //   ]; // 메트릭스
      //   const d = [
      //     [
      //       [1, 2],
      //       [1, 2],
      //       [1, 2],
      //     ],
      //     [
      //       [1, 2],
      //       [1, 2],
      //       [1, 2],
      //     ],
      //     [
      //       [1, 2],
      //       [1, 2],
      //       [1, 2],
      //     ],
      //   ]; // 텐서(3차원 이상의 다차원)

      // 그렇기에 인공지능 중 가장 유명한 라이브러리 텐서플로우는 결국 다차원 행렬의 연산입니다.

      // push()
      const myArray1 = [1, 2, 3];
      myArray1.push(4);
      console.log(myArray1);

      // push 실무 예제
      //   let tableBodyData = [];
      //   for (const iterator of data) {
      //     tableBodyData.push(`
      //         <tr>
      //             <td>${iterator["a"]}</td>
      //             <td>${iterator["b"]}</td>
      //             <td>${iterator["c"]}</td>
      //             <td>${iterator["d"]}</td>
      //             <td>${iterator["e"]}</td>
      //             <td>${iterator["f"]}</td>
      //         </tr>
      //       `);
      //   }
      //   document.querySelector("#dataTable > tbody").innerHTML =
      //     tableBodyData.join("");

      // pop()
      // 1. 마지막에서 값을 꺼내고
      // 2. 꺼낸 값을 반환(return) 합니다.
      const myArray2 = [1, 2, 3, 4, 5];
      myArray2.pop();
      console.log(myArray2); // [1, 2, 3, 4]

      // pop
      const myArray3 = [1, 2, 3, 4, 5];
      let lastValue = myArray3.pop();
      console.log(lastValue); // 5

      // unshift()
      // 앞에 추가(push와 반대)
      const myArray4 = ["사과", "바나나", "수박"];
      myArray4.unshift("오이", "배");
      console.log(myArray4);

      // shift()
      // 1. 앞에서 값을 꺼내고
      // 2. 꺼낸 값을 반환(return) 합니다.
      // pop과 반대
      const myArray5 = ["사과", "바나나", "수박"];
      myArray5.shift();
      console.log(myArray5);

      let firstValue = myArray5.shift();
      console.log(firstValue); // 바나나

      // pop, shift, unshift, push에 대해 설명해주세요.

      // push - 배열의 뒤에 값을 추가한다
      // pop - 뒤에서 값을 꺼내고 반환
      // unshift - 배열의 앞에 값을 추가한다
      // shift - 앞에서 값을 꺼내고 반환

      // arr.splice(start, deleteCount, items)
      let arr4 = [1, 2, 3];
      arr4.splice(1, 0, 4); // arr에 1번째에, 아무것도 삭제하지 않고, 4를 넣겠다.
      console.log(arr4); // [1, 4, 2, 3]

      arr4 = [1, 2, 3];
      arr4.splice(1, 0, [10, 20, 30]); // arr에 1번째에, 아무것도 삭제하지 않고, [10, 20, 30]를 넣겠다.
      console.log(arr4); // [1, [10, 20, 30], 2, 3]

      arr4 = [1, 2, 3];
      arr4.splice(1, 0, ...[10, 20, 30]); // arr에 1번째에, 아무것도 삭제하지 않고, 10, 20, 30를 넣겠다.
      console.log(arr4); // [1, 10, 20, 30, 2, 3]

      arr4 = [1, 2, 3];
      arr4.splice(1, 0, 10, 20, 30); // arr에 1번째에, 아무것도 삭제하지 않고, 10, 20, 30를 넣겠다.
      console.log(arr4); // [1, 10, 20, 30, 2, 3]

      arr4 = [10, 20, 30, 40, 50];
      const x = [1, 2, 3];
      // 만들고 싶은 값 == [10, 1, 2, 3, 20, 30, 40, 1, 2, 3, 50]
      arr4.splice(1, 0, ...x);
      arr4.splice(7, 0, ...x);
      console.log(arr4);
      // arr.splice().splice() // 메서드 체이닝이 의도한 대로 안되는 이유는 splice는 arr가 아니라 삭제된 값을 반환합니다.
      arr4 = [10, 20, 30, 40, 50];
      console.log(arr4.splice(2, 2, 4)); // [30, 40];

      arr4 = [10, 20, 30, 40, 50];
      arr4.splice(2, 1, 5); // arr에 2번째에, 1개를 삭제하고, 5를 넣는다.
      console.log(arr4); // [10, 20, 5, 40, 50];

      arr4 = [10, 20, 30, 40, 50];
      arr4.splice(2, 2); // 2번째 인덱스에서 값 2개를 삭제합니다. 삽입되는 값은 없습니다.
      console.log(arr4); // [10, 20, 50]

      arr4 = [10, 20, 30, 40, 50];
      arr4.splice(1); // 1번째부터 마지막까지 모두 지움
      console.log(arr4); // [10]

      arr4 = [10, 20, 30, 40, 50];
      arr4.splice(2);
      console.log(arr4); // [10, 20]

      // arr.slice(start, end전까지)
      const myArray6 = ["apple", "banana", "cherry", "durian", "elderberry"];
      console.log(myArray6.slice(1, 4)); // ["banana", "cherry", "durian"]
      console.log(myArray6); // ["apple", "banana", "cherry", "durian", "elderberry"] (원래 배열은 바뀌지 않음)
      console.log(myArray6.slice(1)); // ["banana", "cherry", "durian", "elderberry"]
      console.log(myArray6.slice(0, 100)); // ["apple", "banana", "cherry", "durian", "elderberry"]

      ////////////

      arr4 = [10, 20, 30, 40, 50];
      // arr.forEach(함수)
      // 함수(callbackfn): (value: number, index: number, array: number[]
      // callback function
      arr4.forEach(function (item, index) {
        console.log(index, item);
      });

      arr4.forEach(function (item, index, arr) {
        console.log(index, item, arr); // arr = 자기 자신의 배열
      });

      // 실무에서 사용하는 코드는 아닙니다.
      arr4 = Array(100).fill(0);
      let arr5 = [];

      // 같은 코드1 (이름이 없는 함수 사용)
      arr4.forEach(function (item, index) {
        arr5.push(index + 1);
      });
      console.log(arr4);

      // 같은 코드2 (화살표 함수 사용)
      arr4.forEach((item, index) => {
        arr5.push(index + 1);
      });

      // 같은 코드3 (중괄호를 생략한 화살표 함수 사용, 주로 이렇게 실무에서 사용합니다.)
      arr4.forEach((item, index) => arr5.push(index + 1));

      // 어제 진행했었던 코드
      //   fetch("http://test.api.weniv.co.kr/mall")
      //     .then((data) => data.json())
      //     .then((data) => {
      //       data.forEach((item) => {
      //         console.log(item.thumbnailImg);
      //         console.log(item.productName);
      //         console.log(item.price);
      //       });
      //     });

      // https://caniuse.com/?search=forEach
      // nodeList에서 forEach와 Array에서 forEach는 다릅니다.
      // nodeList에서 forEach는 익스플로러를 지원하지 않습니다.

      const avengers = ["spiderman", "ironman", "hulk", "thor"];

      const newAvengers = [];
      avengers.forEach(function (item) {
        newAvengers.push("💖" + item + "💖");
      });
      console.log(newAvengers);

      // map (면접 질문에서도 많이 나옵니다. 데이터를 뽑으려고 많이 사용합니다.)
      // map은 forEach와 다르게 새로운 배열을 생성합니다.

      let arr6 = [1, 2, 3];
      let mapArr = arr6.map(function (item, index) {
        return item ** 2;
      });
      console.log(mapArr); // [1, 4, 9];

      // 같은 코드 1
      let arr7 = Array(100).fill(0);
      let mapArr2 = arr7.map((v, i) => i);
      console.log(mapArr2);

      // 같은 코드 2
      mapArr2 = arr7.map(function (v, i) {
        return i;
      });
      console.log(mapArr2);

      // 같은 코드 3
      function hojun(v, i) {
        return i;
      }
      mapArr2 = arr7.map(hojun);
      console.log(mapArr2);

      // 같은 코드 4
      mapArr2 = arr7.map((v, i) => {
        return i;
      });
      console.log(mapArr2);

      // 실무 팁(***)
      let tip1 = [1, 2, 3, 4, 5];
      console.log(tip1[tip1.length - 1]); // 5
      // 원본 수정 없이 [1, 2, 3, 4] 값과 [5]라는 값을 얻어내고 싶을 때
      console.log([...tip1].pop()); // 5 (원래 tip1 배열이 바뀌지 않음)
      console.log(tip1); // [1, 2, 3, 4, 5]
      let tip2 = [...tip1];
      console.log(tip2.pop()); // 5
      console.log(tip2); // [1, 2, 3, 4]

      let tip3 = [1, 2, 3, 4, 5];
      let tip4 = [10, 20, 30, 40, 50];

      console.log([...tip3, 1000, ...tip4]); // [1, 2, 3, 4, 5, 1000, 10, 20, 30, 40, 50]

      const tip5 = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9],
      ];

      // 다차원 배열에서 최솟값, 최댓값 찾기
      console.log(tip5.flat()); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
      console.log(Math.max(tip5.flat())); // NaN
      console.log(Math.max(...tip5.flat())); // 9

      const tip6 = [
        [
          [1, 2],
          [1, 2],
          [1, 2],
        ],
        [
          [1, 2],
          [1, 2],
          [1, 2],
        ],
        [
          [1, 2],
          [1, 2],
          [1, 2],
        ],
      ];

      console.log(tip6.flat()); // [[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]
      console.log(tip6.flat(1)); // [[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]
      console.log(tip6.flat(2)); // [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
      console.log(tip6.flat(Infinity)); // [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2] (다 펼쳐질때까지)

      const tip7 = new Array(10).fill(0); // Array(10).fill(0)도 됩니다.
      const tip8 = Array.from("hello world");
      console.log(tip7);
      console.log(tip8); // ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

      console.log(".".repeat(100).split(".")); // ['', '', '', '', '', '', '', '', '', '', '', '', …]

      let tip9 = [1, 2, 3, 4, 5];
      console.log([tip9.slice(0, 2), 1000, tip9.slice(2, 5)]); // [[1, 2], 1000, [3, 4, 5]
      console.log([...tip9.slice(0, 2), 1000, ...tip9.slice(2, 5)]); // [1, 2, 1000, 3, 4, 5]

      let tip10 = [1, 2, 3, 4, 5];
      console.log(tip10.splice(2, 0, 1000)); // []
      console.log(tip10); // [1, 2, 1000, 3, 4, 5]

      const tip11 = Array(100)
        .fill(0)
        .map((v, i) => i + 1);
      console.log(tip11);

      const tip12 = [
        {
          _id: "642ba3980785cecff3f39a8d",
          index: 0,
          age: 28,
          eyeColor: "green",
          name: "Annette Middleton",
          gender: "female",
          company: "KINETICA",
        },
        {
          _id: "642ba398d0fed6e17f2f50c9",
          index: 1,
          age: 37,
          eyeColor: "green",
          name: "Kidd Roman",
          gender: "male",
          company: "AUSTECH",
        },
        {
          _id: "642ba39827d809511d00dd8d",
          index: 2,
          age: 39,
          eyeColor: "brown",
          name: "Best Ratliff",
          gender: "male",
          company: "PRISMATIC",
        },
      ];

      const ages1 = tip12.map((item) => item.age);
      console.log(ages1); // [28, 37, 39],
    </script>
  </body>
</html>
